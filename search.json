[{"title":"X-ui面板的安装与配置","date":"2023-11-24T08:13:57.000Z","url":"/2023/11/24/X-ui%E9%9D%A2%E6%9D%BF%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/","categories":[["undefined",""]],"content":"功能介绍系统状态监控支持多用户多协议，网页可视化操作支持的协议：vmess、vless、trojan、shadowsocks、dokodemo-door、socks、http支持配置更多传输配置流量统计，限制流量，限制到期时间可自定义 xray 配置模板支持 https 访问面板（自备域名 + ssl 证书）更多高级配置项，详见该项目的 GitHub：点击访问 准备工作1、VPS 一台重置好主流的操作系统 （CentOS 7+、Ubuntu 16+、Debian 8+），作者使用：搬瓦工 VPS 2、域名一个，做好相关的解析，若是需要套用 CDN，请托管域名到 cloudflare ，不会请点击 安装 X-ui 面板安装 &amp; 升级 X-ui 面板更新及安装组件下面环境的安装方式，大家根据自己的系统选择命令安装就好了。 请注意！！！！！ 以下的两个安装命令： 1 为官方原版，但是2021年8月就没有更新了。 2 为改版X-ui，更新速度值得点赞，加入了很多的新功能，包括最新的 Reality 协议、电报群通知等等功能。 大家自由选择，二选一，都可以正常的使用 1、官方原版安装及升级的一键代码 2、改版X-ui项目地址：点击访问 申请 SSL 证书若是不明白 SSL 证书为何物，请看这里：点击观看 若是不明白怎么申请 SSL 证书，请看 本期视频 若你不明白我在说什么，请直接看这里：点击观看 安装 Acme 脚本 80 端口空闲的证书申请方式自行更换代码中的域名、邮箱为你解析的域名及邮箱 安装证书到指定文件夹自行更换代码中的域名为你解析的域名 节点配置及功能讲解 节点配置及龙能方面，请看 视频教程 V2-ui – X-ui数据迁移安装完 X-ui 以后，输入以下代码，即可完成用户数据的迁移（不包含管理员账号及密码，仅针对已部署的节点部分）"},{"title":"Hexo使用心得","date":"2023-11-23T09:50:25.000Z","url":"/2023/11/23/Hexo%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/","tags":[["Hexo技巧","/tags/Hexo%E6%8A%80%E5%B7%A7/"],["Hexo插件","/tags/Hexo%E6%8F%92%E4%BB%B6/"]],"categories":[["HEXO系列","/categories/HEXO%E7%B3%BB%E5%88%97/"]],"content":"Hexo 是一个基于 Node.js 的静态博客生成器，它可以帮助你轻松地创建和管理博客。以下是 Hexo 的详细使用教程： 安装 Hexo安装 Node.js 和 npm： Hexo 依赖于 Node.js 和 npm。你可以从 Node.js 官网 下载并安装它们。 安装 Hexo： 打开终端（命令行），运行以下命令来安装 Hexo： 创建 Hexo 项目初始化 Hexo 项目： 在终端中，进入你想要创建博客的目录，运行以下命令初始化 Hexo 项目： 进入项目目录： 使用 cd 命令进入你的 Hexo 项目目录： 安装依赖： 运行以下命令安装项目依赖： 编写和发布文章新建文章： 运行以下命令来新建一篇文章： 这将在 source&#x2F;_posts 目录下创建一个 Markdown 文件，你可以在这里编写文章内容。 编辑文章： 使用任何你喜欢的文本编辑器编辑新创建的 Markdown 文件。 预览文章： 运行以下命令启动本地服务器，预览你的博客： 打开浏览器，访问 ，你将看到你的博客。 部署博客配置 _config.yml： 打开项目目录下的 _config.yml 文件，配置你的博客信息和部署选项。确保设置了 deploy 部分。 生成静态文件： 运行以下命令生成静态文件： 部署到远程： 根据你的部署配置，运行以下命令将生成的静态文件部署到远程服务器或平台： 主题和插件安装主题： 从 Hexo 主题 中选择一个你喜欢的主题，并按照主题文档的说明安装和配置。 安装插件： Hexo 有很多插件可以扩展功能。你可以在 Hexo 插件列表 中找到并按照文档安装。 常用命令hexo new “My New Post”: 新建文章hexo generate 或 hexo g: 生成静态文件hexo server 或 hexo s: 启动本地服务器预览hexo deploy 或 hexo d: 部署博客hexo clean: 清除缓存文件（在重新生成之前运行）以上是 Hexo 的基本用法，希望这份简单的教程能够帮助你开始使用 Hexo 构建自己的博客。如果需要更多详细信息，请参考 Hexo 官方文档。"},{"title":"使用hexo换了电脑后如何更新博客","date":"2021-07-22T09:27:25.000Z","url":"/2021/07/22/%E4%BD%BF%E7%94%A8hexo%E6%8D%A2%E4%BA%86%E7%94%B5%E8%84%91%E5%90%8E%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2/","tags":[["git page","/tags/git-page/"],["hexo换电脑","/tags/hexo%E6%8D%A2%E7%94%B5%E8%84%91/"],["git使用技巧","/tags/git%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"]],"categories":[["HEXO系列","/categories/HEXO%E7%B3%BB%E5%88%97/"]],"content":""},{"title":"Git常用命令及方法大全","date":"2021-07-22T08:51:05.000Z","url":"/2021/07/22/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E6%96%B9%E6%B3%95%E5%A4%A7%E5%85%A8/","categories":[["undefined",""]],"content":" 下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。 Workspace：工作区 Index &#x2F; Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 本地分支关联远程：git branch –set-upstream-to&#x3D;origin&#x2F;beta beta 一、新建代码库 # 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] # 下载一个项目和它的整个代码历史 $ git clone [url] 二、配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 # 显示当前的Git配置 $ git config –list # 编辑Git配置文件 $ git config -e [–global] # 设置提交代码时的用户信息 $ git config [–global] user.name “[name]” 三、增加&#x2F;删除文件 # 添加指定文件到暂存区 $ git add [file1] [file2] … # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . 四、代码提交 # 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] … -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a 五、分支 # 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a 六、标签 # 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] 七、查看信息 # 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log –stat 八、远程同步 # 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] 九、撤销 # 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . 十、其他 # 生成一个可供发布的压缩包 $ git archive Git分支管理策略一、主分支Master 首先，代码库应该有一个、且仅有一个主分支。所有提供给用户使用的正式版本，都在这个主分支上发布。 Git主分支的名字，默认叫做Master。它是自动建立的，版本库初始化以后，默认就是在主分支在进行开发。 二、开发分支Develop 主分支只用来分布重大版本，日常开发应该在另一条分支上完成。我们把开发用的分支，叫做Develop。 这个分支可以用来生成代码的最新隔夜版本（nightly）。如果想正式对外发布，就在Master分支上，对Develop分支进行”合并”（merge）。 Git创建Develop分支的命令： git checkout -b develop master 将Develop分支发布到Master分支的命令： # 切换到Master分支 git checkout master # 对Develop分支进行合并 git merge –no-ff develop 这里稍微解释一下，上一条命令的–no-ff参数是什么意思。默认情况下，Git执行”快进式合并”（fast-farward merge），会直接将Master分支指向Develop分支。 使用–no-ff参数后，会执行正常合并，在Master分支上生成一个新节点。为了保证版本演进的清晰，我们希望采用这种做法。关于合并的更多解释，请参考Benjamin Sandofsky的《Understanding the Git Workflow》。 三、临时性分支 前面讲到版本库的两条主要分支：Master和Develop。前者用于正式发布，后者用于日常开发。其实，常设分支只需要这两条就够了，不需要其他了。 但是，除了常设分支以外，还有一些临时性分支，用于应对一些特定目的的版本开发。临时性分支主要有三种： * 功能（feature）分支 * 预发布（release）分支 * 修补bug（fixbug）分支 这三种分支都属于临时性需要，使用完以后，应该删除，使得代码库的常设分支始终只有Master和Develop。 四、 功能分支 接下来，一个个来看这三种”临时性分支”。 第一种是功能分支，它是为了开发某种特定功能，从Develop分支上面分出来的。开发完成后，要再并入Develop。 功能分支的名字，可以采用feature-*的形式命名。 创建一个功能分支： git checkout -b feature-x develop 开发完成后，将功能分支合并到develop分支： git checkout develop git merge –no-ff feature-x 删除feature分支： git branch -d feature-x 五、预发布分支 第二种是预发布分支，它是指发布正式版本之前（即合并到Master分支之前），我们可能需要有一个预发布的版本进行测试。 预发布分支是从Develop分支上面分出来的，预发布结束以后，必须合并进Develop和Master分支。它的命名，可以采用release-*的形式。 创建一个预发布分支： git checkout -b release-1.2 develop 确认没有问题后，合并到master分支： git checkout master git merge –no-ff release-1.2 # 对合并生成的新节点，做一个标签 git tag -a 1.2 再合并到develop分支： git checkout develop git merge –no-ff release-1.2 最后，删除预发布分支： git branch -d release-1.2 六、修补bug分支 最后一种是修补bug分支。软件正式发布以后，难免会出现bug。这时就需要创建一个分支，进行bug修补。 修补bug分支是从Master分支上面分出来的。修补结束以后，再合并进Master和Develop分支。它的命名，可以采用fixbug-*的形式。 创建一个修补bug分支： git checkout -b fixbug-0.1 master 修补结束后，合并到master分支： git checkout master git merge –no-ff fixbug-0.1 git tag -a 0.1.1 再合并到develop分支： git checkout develop git merge –no-ff fixbug-0.1 最后，删除”修补bug分支”： git branch -d fixbug-0.1 版本回退-撤销文件修改{针对文件修改恢复} 工作区修改一个文件后，又想回到修改前(git add前)\\1. 当然可以直接手动再在工作区中将文件修改回去 \\2. 修改后，通过命令git status查看 $ git status # On branch master # Changes not staged for commit: # (use “git add …” to update what will be committed) # (use “git checkout – …” to discard changes in working directory) # # modified: readme.txt # no changes added to commit (use “git add” and&#x2F;or “git commit -a”) 这时Git会告诉你，git checkout – file可以丢弃工作区的修改： Note: \\1. git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。 \\2. 命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。总之，就是让这个文件回到最近一次git commit或git add时的状态。 \\3. 工作区、暂存区的概念不清楚的可见于Git版本控制教程 - Git本地仓库 如果在工作区中修改了文件还git add到暂存区（但是在commit之前）用git status查看一下，修改只是添加到了暂存区，还没有提交： $ git status # On branch master # Changes to be committed: # (use “git reset HEAD …” to unstage) # # modified: readme.txt # Git同样告诉我们，用命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区： $ git reset HEAD readme.txt Unstaged changes after reset: M readme.txt git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 再用git status查看一下，现在暂存区是干净的，工作区有修改。 然后丢弃工作区的修改 $ git checkout – readme.txt $ git status # On branch master nothing to commit (working directory clean) 不但修改了文件还从暂存区提交commit到了版本库 - 版本回退版本回退可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。Git是分布式版本控制系统。 在工作中对某个文件（如readme.txt）进行多次修改交commit。 可以通过版本控制系统命令告诉我们提交的历史记录，在Git中，我们用git log命令查看： $ git log commit 3628164fb26d48395383f8f31179f24e0882e1e0 Author: Michael Liao &#x61;&#x73;&#x6b;&#120;&#117;&#101;&#102;&#101;&#110;&#103;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d; Date: Tue Aug 20 15:11:49 2013 +0800 append GPL commit ea34578d5496d7dd233c827ed32a8cd576c5ee85 Author: Michael Liao &#97;&#x73;&#x6b;&#120;&#x75;&#101;&#x66;&#101;&#x6e;&#x67;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109; Note: \\1. git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。 \\2. 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上–pretty&#x3D;oneline参数： $ git log –pretty&#x3D;oneline 3628164fb26d48395383f8f31179f24e0882e1e0 append GPL ea34578d5496d7dd233c827ed32a8cd576c5ee85 add distributed cb926e7ea50ad11b8f9e909c05226233bf755030 wrote a readme file \\3. 你看到的一大串类似3628164…882e1e0的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。 \\4. 每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具（如GitX、github的客户端、pycharm）查看Git历史，就可以更清楚地看到提交历史的时间线。0 现在我们想要把readme.txt回退到上一个版本如“add distributed”的那个版本，怎么做呢？首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交3628164…882e1e0（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 现在，我们要把当前版本“append GPL”回退到上一个版本“add distributed”，就可以使用git reset命令： $ git reset –hard HEAD^ HEAD is now at ea34578 add distributed 这时readme.txt的内容就成了版本add distributed 我们用git log再看看现在版本库的状态： $ git log commit ea34578d5496d7dd233c827ed32a8cd576c5ee85 Author: Michael Liao &#97;&#x73;&#x6b;&#x78;&#117;&#101;&#102;&#101;&#x6e;&#x67;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d; Date: Tue Aug 20 14:53:12 2013 +0800 add distributed commit cb926e7ea50ad11b8f9e909c05226233bf755030 Author: Michael Liao &#x61;&#x73;&#107;&#120;&#117;&#x65;&#x66;&#101;&#110;&#103;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109; 最新的那个版本append GPL已经看不到了！ 恢复文件后，要是我们又想回到修改后的文件呢？（命令行窗口还没有被关掉）{这个是git reset –hard后，又反悔了，想回到修改后的状态} 只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是3628164…，于是就可以指定回到未来的某个版本： $ git reset –hard 3628164 HEAD is now at 3628164 append GPL 版本号没必要写全，前几位就可以了，Git会自动去找。 Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL： 改为指向add distributed： 然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。 恢复文件后，要是我们又想回到修改后的文件呢？（命令行窗口早就关掉了）{这个是git reset –hard后，又反悔了，想回到修改后的状态} 想恢复到新版本怎么办？找不到新版本的commit id怎么办？当你用$ git reset –hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。 Git提供了一个命令git reflog用来记录你的每一次命令：[Git高级教程:git log与git reflog] $ git reflog ea34578 HEAD@{0}: reset: moving to HEAD^ 3628164 HEAD@{1}: commit: append GPL ea34578 HEAD@{2}: commit: add distributed cb926e7 HEAD@{3}: commit (initial): wrote a readme file 第二行显示append GPL的commit id是3628164，现在，你又可以乘坐时光机回到未来了。"},{"title":"tar压缩解压缩命令详解","date":"2021-07-22T08:30:52.000Z","url":"/2021/07/22/tar%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/","tags":[["Linux文件解压","/tags/Linux%E6%96%87%E4%BB%B6%E8%A7%A3%E5%8E%8B/"],["gzip","/tags/gzip/"],["tar命令","/tags/tar%E5%91%BD%E4%BB%A4/"]],"categories":[["Linux学习","/categories/Linux%E5%AD%A6%E4%B9%A0/"]],"content":"tar命令详解 -c: 建立压缩档案 -x：解压 -t：查看内容 -r：向压缩归档文件末尾追加文件 -u：更新原压缩包中的文件 这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。 下面的参数是根据需要在压缩或解压档案时可选的。 -z：有gzip属性的 -j：有bz2属性的 -Z：有compress属性的 -v：显示所有过程 -O：将文件解开到标准输出 参数-f是必须的 -f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。 # tar -cf all.tar *.jpg 这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。# tar -rf all.tar *.gif 这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。# tar -uf all.tar logo.gif 这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。# tar -tf all.tar 这条命令是列出all.tar包中所有文件，-t是列出文件的意思# tar -xf all.tar 这条命令是解出all.tar包中所有文件，-x是解开的意思 查看tar -tf aaa.tar.gz 在不解压的情况下查看压缩包的内容 压缩 tar –cvf jpg.tar *.jpg &#x2F;&#x2F;将目录里所有jpg文件打包成tar.jpg tar –czf jpg.tar.gz *.jpg &#x2F;&#x2F;将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz tar –cjf jpg.tar.bz2 *.jpg &#x2F;&#x2F;将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2 tar –cZf jpg.tar.Z *.jpg &#x2F;&#x2F;将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z 解压 tar –xvf file.tar &#x2F;&#x2F;解压 tar包 tar -xzvf file.tar.gz &#x2F;&#x2F;解压tar.gz tar -xjvf file.tar.bz2 &#x2F;&#x2F;解压 tar.bz2tar –xZvf file.tar.Z &#x2F;&#x2F;解压tar.Z 总结 1、*.tar 用 tar –xvf 解压 2、*.gz 用 gzip -d或者gunzip 解压 3、*.tar.gz和*.tgz 用 tar –xzf 解压 4、*.bz2 用 bzip2 -d或者用bunzip2 解压 5、*.tar.bz2用tar –xjf 解压 6、*.Z 用 uncompress 解压 7、*.tar.Z 用tar –xZf 解压"},{"title":"如何查看当前Ubuntu系统的版本","date":"2021-07-22T08:25:09.000Z","url":"/2021/07/22/%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8DUbuntu%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%88%E6%9C%AC/","tags":[["Ubuntu系统命令","/tags/Ubuntu%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/"],["Linux 系统技巧","/tags/Linux-%E7%B3%BB%E7%BB%9F%E6%8A%80%E5%B7%A7/"],["Uname","/tags/Uname/"]],"categories":[["Linux学习","/categories/Linux%E5%AD%A6%E4%B9%A0/"]],"content":"说来也惭愧，用Ubuntu差不多快1个月了，双系统是让朋友安的，只知道自己使用的是什么12版本的，具体怎么看还不知道，下面写一下查看当前Linux系统的版本的方法 注：proc目录下记录的当前系统运行的各种数据，version记录的版本信息直接可以通过cat查看到。第一种 使用命令：cat &#x2F;proc&#x2F;version 查看 proc目录下记录的当前系统运行的各种数据,version记录的版本信息可以直接通过cat查看到，还可以看到我的gcc版本呢。 第二种 使用命令：uname -a 查看 ​ 第三种 ​ 原来我的版本是12.04啊，晓得了————————————————版权声明：本文为CSDN博主「玖零大壮」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接："},{"title":"编译OpenWRT过程问题解决","date":"2021-07-22T07:42:25.000Z","url":"/2021/07/22/%E7%BC%96%E8%AF%91OpenWRT%E8%BF%87%E7%A8%8B%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","tags":[["openwrt编译","/tags/openwrt%E7%BC%96%E8%AF%91/"],["openwrt报错","/tags/openwrt%E6%8A%A5%E9%94%99/"],["feeds update","/tags/feeds-update/"]],"categories":[["openwrt系列","/categories/openwrt%E7%B3%BB%E5%88%97/"]],"content":"本人是只菜鸟，没有接触过OpenWrt，只是平时都是在Linux下做开发。习惯了Linux的开发环境。 本人的操作系统是CentOS 6.4（好久都没有换过了）。本人按照网上牛人们的指点也开始下载编译OpenWRT。 如下为网上的资料： sudo apt-get update (更新）安装编译需要的组件：sudo apt-get install gccsudo apt-get install g++sudo apt-get install binutilssudo apt-get install patchsudo apt-get install bzip2sudo apt-get install flexsudo apt-get install bisonsudo apt-get install makesudo apt-get install autoconfsudo apt-get install gettextsudo apt-get install texinfosudo apt-get install unzipsudo apt-get install sharutilssudo apt-get install subversionsudo apt-get install libncurses5-devsudo apt-get install ncurses-termsudo apt-get install zlib1g-devsudo apt-get install gawksudo apt-get install asciidocsudo apt-get install libz-dev 编译环境搭建完成mkdir openwrt 创建一个openwrt文件夹cd openwrt 进入openwrt文件夹svn co svn:&#x2F;&#x2F;svn.openwrt.org&#x2F;openwrt&#x2F;branches&#x2F;backfire 下载官网的源码.&#x2F;scripts&#x2F;feeds update -a 更新软件包.&#x2F;scripts&#x2F;feeds install -a 安装软件包make menuconfig 进入定制界面（里面可以选择芯片的型号，集成的组件等等，根据实际情况选择）defconfigmake V&#x3D;99 （开始编译）剩下的就是等待了，第一次编译需要的时间相对比较长，这个跟你的电脑配置和网速有关。 由于原作者是用的Ubuntu作为开发环境，所以在安装上面的那些依赖工具包时都是用 apt-get 来安排的，在CentOS里采用 yum。其实都一样，只要知道依赖哪些包就行了。 本人checkout 的OpenWRT源码库路径为 ： svn:&#x2F;&#x2F;svn.openwrt.org&#x2F;openwrt&#x2F;trunk 其它的都按上面的步骤做。 如下是我遇到的几个问题： .&#x2F;scripts&#x2F;feeds update -a失败报： 可能是git仓库路径不对，将https替换成git就可以了。 用 grep 命令搜 那就把这个地方改一下啰。 再试一下。结果还是老样子，我想了一下，这个 feeds&#x2F;packages.tmp&#x2F;location 很可能是临时文。改它不会有效果的。 好像 feeds.conf.default 文件里也找到了。 将里面所有https替换成git。 再试一下，OK了。 后记：其实还有更根本的解决方法，详见后期的博文《git 错误：Unable to find remote helper for ‘https’》 gconvert.c libiconv我在第一次编译OpenWRT时，出现如下错误提示： 我在网上找解决方案，结果一致地都是说，重新 .&#x2F;configure 一下： 可问题的关键是：OpenWRT的trunk路径下没见有个 configure 呀！ 后来，经过仔细推敲，发现是在编glib时没通过。 那我就直接进到 .&#x2F;build_dir&#x2F;host&#x2F;pkg-config-0.28&#x2F;glib&#x2F; 路径下，发现该路径下有 configure 文件。 那我说直接在该路径下编译 glib 这样，glib 就顺利通过了编译。 再回到 OpenWRT的trunk路径下，继续 make. libubox安装错误报错： 从第二行看出，是用git clone工程： 整个第三行是将clone下来的源码打包tar.gz包。 于是，我访问了一下： 果然出现 404页面。看来还真没有？ 我再访问了一下： 结果，发现列表里有这个工程： 进入链接 project&#x2F;libubox.git： 我自己亲自 git clone 一下。 我在网上找了“fatal: Unable to find remote helper for ‘http’”的解决方法。得知将 “http:” 换成 “git:” 即可。 于是，我再次 git clone 结果成功clone了。 然后，手动完成编译命令过程： 然后，回到OpenWRT的trunk路径下继续 make. fatal: Unable to find remote helper for ‘http’编译报错： 找到 package&#x2F;network&#x2F;config&#x2F;netifd&#x2F;Makefile，打开 将第8行的“http:”替换成”git:”，然后再回到OpenWRT目录再make. 注：后来我还会反复遇到这个问题。火了！一条命令全部换掉！ 在trunk目录下，找出Makefile中有”http:xxxxx.git”的文件，并将所有的”http:xxxxx.git”替换成”git:xxxxx.git” 把 https 也替换成 git opkg下载失败 这时往上看一下，看make到哪儿了 原来是 opkg 在 git clone 时可能是路径的问题，失败了。 我尝试打开 opkg 路径下的 Makefile，将 改成： 结果还是没有生效。 我手动搜opkg，找到官网：  打开，看到网页最下面有： 于是，我改 trunk&#x2F;package&#x2F;system&#x2F;opkg&#x2F;Makefile 文件，把 PKG_SOURCE_URL改成： 继续 make，通过了！ linux-firmware clone失败 我到 git.kernel.org 网站找到了 linux-firmware 的仓库  看到最下面的 git 路径说明： 这与 Makefile 里指定的不统一。于是将Makefile里的git路径改过来 再 make 我现在都总结出经验来了。 凡是git clone失败的，如果是http头的问题，将http替换成git再试。 如果还是不行，就要检查一下git的路径是不是对的。简单的方法就是到 git 路径的根节点上去找出源码仓库，并得到其真实有效的git路径。 并将Makefile中的改过来就OK了。 linux-firmware fatal: reference is not a tree 问题 fatal: reference is not a tree: f404….22c，意思好像是说git工程里没有 f404…22c 这么版本。那么我得检查一下这个版本号对不对。 在trunk&#x2F;tmp&#x2F;dl路径下下载的linux-firmware还没有删掉，我们进入该目录。并用git log查看一下提交日志，得到： 在这里面，没有搜到 f404336ba808cbd57547196e13367079a23b822c 这个版本号 那，我就将其改成最新的版本号吧 b8ac7c7e27dcd13fa3c843aaf62457e9c57ea4db，但愿没有问题。 同时，将 trunk&#x2F;tmp&#x2F;dl&#x2F;下的原下载目录改名（避免反复下载）、 好！我们再 make 一下。 openwrt编译 © 著作权归作者所有 举报 打赏 2 赞 39 收藏 分享 作者的其它热门文章OpenWRT开发之——创建软件包(有更新) OpenWRT开发之——研究包的Makefile OpenWrt的ipk包安装 用PyCharm建Django工程"},{"title":"openwrt_feeds update报错","date":"2021-07-22T07:38:03.000Z","url":"/2021/07/22/openwrt-feeds-update%E6%8A%A5%E9%94%99/","tags":[["openwrt编译","/tags/openwrt%E7%BC%96%E8%AF%91/"],["openwrt固件","/tags/openwrt%E5%9B%BA%E4%BB%B6/"],["openwrt刷机","/tags/openwrt%E5%88%B7%E6%9C%BA/"]],"categories":[["openwrt系列","/categories/openwrt%E7%B3%BB%E5%88%97/"]],"content":"问题：下载好openwrt后，进行.&#x2F;scripts&#x2F;feeds update -a 这一步时报错。 原因：是因为git-core的路径没有在path中，这导致里面的git-remote-https, git-remote-http 这些得不到执行，所以git所表现出来的功能不全。 解决办法：先找到你的git-core的路径，我的是&#x2F;usr&#x2F;lib&#x2F;git-core，然后将它添加到path中 1.命令行输入：PATH&#x3D;$PATH:&#x2F;usr&#x2F;lib&#x2F;git-core 2.修改 &#x2F;etc&#x2F;environment 注意：已经打开的终端需要关掉重新打开对应终端才生效。————————————————版权声明：本文为CSDN博主「winnerycy」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接："},{"title":"linux使用find命令和grep命令查找文件和文件内容","date":"2021-07-22T01:15:05.000Z","url":"/2021/07/22/linux%E4%BD%BF%E7%94%A8find%E5%91%BD%E4%BB%A4%E5%92%8Cgrep%E5%91%BD%E4%BB%A4%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9/","tags":[["Linux技巧","/tags/Linux%E6%8A%80%E5%B7%A7/"],["find使用","/tags/find%E4%BD%BF%E7%94%A8/"],["Linux查找命令","/tags/Linux%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/"]],"categories":[["Linux学习","/categories/Linux%E5%AD%A6%E4%B9%A0/"]],"content":" 区别： 在使用linux时，经常需要进行文件查找。其中查找的命令主要有find和grep。两个命令是有区的。 find命令是根据文件的属性进行查找，如文件名，文件大小，所有者，所属组，是否为空，访问时间，修改时间等。 grep是根据文件的内容进行查找，会对文件的每一行按照给定的模式(patter)进行匹配查找。 一.find命令 基本格式：find path expression1. 按照文件名查找(1)find &#x2F; -name httpd.conf #在根目录下查找文件httpd.conf，表示在整个硬盘查找(2)find &#x2F;etc -name httpd.conf #在&#x2F;etc目录下文件httpd.conf(3)find &#x2F;etc -name ‘srm‘ #使用通配符*(0或者任意多个)。表示在&#x2F;etc目录下查找文件名中含有字符串‘srm’的文件(4)find . -name ‘srm*’ #表示当前目录下查找文件名开头是字符串‘srm’的文件 2.按照文件特征查找(1)find &#x2F; -amin -10 # 查找在系统中最后10分钟访问的文件(access time)(2)find &#x2F; -atime -2 # 查找在系统中最后48小时访问的文件(3)find &#x2F; -empty # 查找在系统中为空的文件或者文件夹(4)find &#x2F; -group cat # 查找在系统中属于 group为cat的文件(5)find &#x2F; -mmin -5 # 查找在系统中最后5分钟里修改过的文件(modify time)(6)find &#x2F; -mtime -1 #查找在系统中最后24小时里修改过的文件(7)find &#x2F; -user fred #查找在系统中属于fred这个用户的文件(8)find &#x2F; -size +10000c #查找出大于10000000字节的文件(c:字节，w:双字，k:KB，M:MB，G:GB)(9)find &#x2F; -size -1000k #查找出小于1000KB的文件 3.使用混合查找方式查找文件参数有： ！，-and(-a)，-or(-o)。 (1)find &#x2F;tmp -size +10000c -and -mtime +2 #在&#x2F;tmp目录下查找大于10000字节并在最后2分钟内修改的文件(2)find &#x2F; -user fred -or -user george #在&#x2F;目录下查找用户是fred或者george的文件文件(3)find &#x2F;tmp ! -user panda #在&#x2F;tmp目录中查找所有不属于panda用户的文件 二、grep命令基本格式：find expression1.主要参数[options]主要参数：－c：只输出匹配行的计数。－i：不区分大小写－h：查询多文件时不显示文件名。－l：查询多文件时只输出包含匹配字符的文件名。－n：显示匹配行及行号。－s：不显示不存在或无匹配文本的错误信息。－v：显示不包含匹配文本的所有行。 pattern正则表达式主要参数：\\： 忽略正则表达式中特殊字符的原有含义。^：匹配正则表达式的开始行。$: 匹配正则表达式的结束行。&lt;：从匹配正则表达 式的行开始。&gt;：到匹配正则表达式的行结束。[ ]：单个字符，如[A]即A符合要求 。[ - ]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。.：所有的单个字符。* ：有字符，长度可以为0。 2.实例 (1)grep ‘test’ d* #显示所有以d开头的文件中包含 test的行 (2)grep ‘test’ aa bb cc #显示在aa，bb，cc文件中包含test的行 (3)grep ‘[a-z]{5}’ aa #显示所有包含每行字符串至少有5个连续小写字符的字符串的行 (4)grep magic &#x2F;usr&#x2F;src #显示&#x2F;usr&#x2F;src目录下的文件(不含子目录)包含magic的行 (5)grep -r magic &#x2F;usr&#x2F;src #显示&#x2F;usr&#x2F;src目录下的文件(包含子目录)包含magic的行 (6)grep -w pattern files ：只匹配整个单词，而不是字符串的一部分(如匹配’magic’，而不是’magical’)， 详细使用参见： 转载于:"},{"title":"如何在github上获取指定版本openwrt源码","date":"2021-07-21T06:32:24.000Z","url":"/2021/07/21/%E5%A6%82%E4%BD%95%E5%9C%A8github%E4%B8%8A%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%ACopenwrt%E6%BA%90%E7%A0%81/","tags":[["Openwrt版本","/tags/Openwrt%E7%89%88%E6%9C%AC/"],["git","/tags/git/"],["Lede","/tags/Lede/"]],"categories":[["openwrt系列","/categories/openwrt%E7%B3%BB%E5%88%97/"]],"content":"wrt和lede版本演进 openwrt github主页 下载lede与openwrt合并后的代码git clone  openwrt与lede合并前的代码已经存档，包括 attitude adjustment、barrier breaker、chaos calmer等三个分支，可以按照以上介绍的方法去下载。 下载地址  "},{"title":"ubuntu16.04 更新git 至最新版本","date":"2021-07-21T06:09:01.000Z","url":"/2021/07/21/ubuntu%E5%8D%87%E7%BA%A7git/","tags":[["git版本","/tags/git%E7%89%88%E6%9C%AC/"],["Git官方的软件源","/tags/Git%E5%AE%98%E6%96%B9%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%BA%90/"],["git --version","/tags/git-version/"]],"categories":[["GIT使用技巧","/categories/GIT%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"]],"content":"1、首先查看一下自己的版本是不是低于最新版： git –version12、若是，添加Git官方的软件源： sudo add-apt-repository ppa:git-core&#x2F;ppa13、接着更新一下软件列表，就可以直接升级安装了： sudo apt updatesudo apt install -fsudo apt upgrade————————————————版权声明：本文为CSDN博主「TB81266」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接："},{"title":"github代码如何定位到历史版本（历史commit点）","date":"2021-07-21T03:03:39.000Z","url":"/2021/07/21/github%E4%BB%A3%E7%A0%81%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E5%88%B0%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC%EF%BC%88%E5%8E%86%E5%8F%B2commit%E7%82%B9%EF%BC%89/","tags":[["git回退","/tags/git%E5%9B%9E%E9%80%80/"],["git技巧","/tags/git%E6%8A%80%E5%B7%A7/"],["新手学git","/tags/%E6%96%B0%E6%89%8B%E5%AD%A6git/"]],"categories":[["GIT使用技巧","/categories/GIT%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"]],"content":"关于使用git在本地进行版本管理见linux下的版本管理 工作项目中git流程实操见git简明实操模板 想我们在写代码时候，数次修改并提交commit，如果在这个过程中我们后悔了，想回到当初的某一个commit点应该如何实现呢？ 如果会用git bash的话，肯定首选命令行模式 三种方式： 1】以目标commit为基础新创建一个分支，并切换到分支上去，这样并不破坏base分支上的任何提交内容，包括你目标commit之前的提交，以及目标commit之后的提交。 例子：你有一个base分支，上面有1&#x2F;2&#x2F;3&#x2F;4四个commit，你现在突然后悔提交了3&#x2F;4两个commit，或者某种原因你需要以2commit为基础，进行另外某个功能的开发。这时候方法1执行 git checkout 2commitID -b div就是以base分支的2commit为基础，创建了子分支div，并切换到子分支上去，原来的base分支并没有受到影响，这时候你也就能在子分支div上看到你的历史代码了。 2】在当前分支上撤销目标commit之后的所有提交，类似于系统还原 例子：还是上面的base分支有1&#x2F;2&#x2F;3&#x2F;4个commit，这时候执行git reset –hard 2commitID 就是放弃3&#x2F;4commit，回退到2commit，这时候你也能看到历史代码，但是在2 commit之后的 3&#x2F;4commit 就永久的丢失了（可以通过一些指令找回来的）。 3】以执行过的指令为目标，进行撤销操作，类似于第二种方法 git log (branch) 查看commit的ID号git checkout commitId -b 新branch名称 （在指定commit的基础上创建新分支） git log (branch)git reset –hard (commit id) 版本回滚 git refloggit reset –hard (command id) 命令撤销如果刚开始接触git，对git的操作不熟悉，只习惯图形界面，那么按照以下方式进行操作 ————————————————版权声明：本文为CSDN博主「半截木头渡海洋」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接："},{"title":"openwrt基本编译","date":"2021-07-21T02:59:52.000Z","url":"/2021/07/21/openwrt%E5%9F%BA%E6%9C%AC%E7%BC%96%E8%AF%91/","tags":[["openwrt编译","/tags/openwrt%E7%BC%96%E8%AF%91/"],["Ubuntu系统","/tags/Ubuntu%E7%B3%BB%E7%BB%9F/"],["SVN","/tags/SVN/"]],"categories":[["openwrt系列","/categories/openwrt%E7%B3%BB%E5%88%97/"]],"content":"本文由明月永在原创，复制或者引用请注明出处www.myopenwrt.org。 编译首先得搭建编译环境，一般推荐用Ubuntu系统，对新手较易上手，使用的人多，碰到问题也容易解决。 特别提醒 一下，编译是一个相当复杂的过程，尤其是新手可能会碰到N多的错误提示，所以提示全是英文的，如果英语水平，根本 看不懂提示内容，你还是不要玩编译的好，要玩几乎是在自虐。还有编译得用linux系统，要求有一定的linux基础，如果你连终端在哪里，隐藏文件怎么看，简单的一些命令都不懂，也不要玩了哈。 Ubuntu系统的安装可在自行搜索，也不难，主要注意下分区时，如果原来硬盘有文件，不要选择全部来安装，否则会数据丢失。 本人使用的是Ubuntu12.04 64位系统，当然也可以用新系统。要编译首先得弄好编译环境，也就是安装一些编译所必须用到的软件。编译openwrt一般是交叉编译，交叉编译就是指编译非x86的软件，和编译所用到的系统的架构不一样的。所编译出来的软件也不能直接在编译的系统里运行。 打开终端，输入以下命令sudo apt-get install gcc g++ binutils patch bzip2 flex bison make autoconf gettext texinfo unzip sharutils subversion libncurses5-dev ncurses-term zlib1g-dev gawk 这里需要提示一下，上面这个命令是针对Ubuntu12.04系统的，新的系统有些软件的版本可能不一样，比如旧的是1.0版本，Ubuntu14.10可能是1.5版本，所以不能完全生搬硬套。要灵活运用。还有些openwrt版本，比如开发版本，在编译时可能会提示少其它的软件，根据提示安装所缺少的软件即可，一般来说如果少一个aaa软件，安装时，最好把aaa.dev也同时装上。新安装的Ubuntu系统最好设置好并更新升级了所有软件后，才安装以上软件，要不可能会提示软件没有。 装好编译环境后，就到官网查找自己所需要的版本来编译。获取源码的方式 有两种，一种是用git，一种是svn，这两种方式 都得安装软件，如果没有就得搜索一下再安装好。本人一般都用svn来获取源码 。编译openwrt的过程里会生成很多的临时文件，体积非常大，虽然固件才几M，编译过程 所生成的文件一般是10G级的，如果你编译多个平台和多个型号，就需要更多的空间。加安装系统最少需要10G，至少 得预留40G+以上的空间。不然编译到一半时，提示没有空间，是非常郁闷的事。 以下的svn获取源码的命令：attitude_adjustment就是所说的AA，上一个稳定版本，当前的稳定版本是barrier_breaker，trunk版本是大家所说的CC，建议用BB来编译。 SVNYou can checkout the source from the OpenWrt Subversion repository using one of the following commands: Development branch: ChangeLog Barrier Breaker 14.07 branch: ChangeLog Attitude Adjustment 12.09 branch: ChangeLog Backfire 10.03 branch: ChangeLog Kamikaze 8.09 branch: ChangeLog Kamikaze 7.09 branch: ChangeLog 如果用BB源码 ，则在终端输入 完成之后，就可以在终端执行make menuconfg来选择自己所需要的软件软件选择可以参考一下恩山的教程当年我也是从这里起步的。第一次编译不要选太多东西，选择好型号后，必选luci界面下的一些软件，要不登录会没界面。其它软件可以尽量少选，先尝试下是否能编译出固件。能成功生成固件，说明编译环境没有问题。 配置好后退出 保存，建议用以下命令来编译 make -j5 V&#x3D;99 2&gt;&amp;1 |tee build.log |grep -i error 这个命令可以生成日志，日志名为buil.log，保存在最高目录下。以方便出错查找原因。-j5参数是4核cpu使用的，其它cpu可以使用内核数量N+1来相应 修改。 输入这个命令后，经过漫长的等待就会出来固件，如果中途有错，查找日志解决后，再执行以上命令就行，一般不必要重新再来。 在编译的过程中，会自动下载应用软件的源码到dl目录下面，选择的软件越多，所需要下载的数据会越大，这些软件的源码 基本都在国外的，所以下载速度极其的慢，甚至有些软件被墙了的，根本下载不了。首次编译一般会耗时几小时，视网络下载速度而定。如果下载不了打看编译日志，来找到错误所在的地方，可以搜索***来定位，有错误的地方一般以这个为标示。然后再找到软件的下载网址，会在出错报告的前面，有ftp或者http链接，里面包含有相应软件名的网址，然后手动下载之后放到dl目录即可。 像我用四核的cpu，全部编译一个16M固件得花一个多小时，不包括下载的时间。由于很多源码在墙外，所以强烈建议大家在弄好翻wall之后，再编译。 新手应该还要注意，openwrt官方所设定的固件大小是按路由出厂的闪存来定的，起步为4M，小于4M的官方都不会支持。所以有一些型号，基本加不了软件，加了软件就会不出固件，因为超出了最大的体积。碰到这种情况，可以少选一些软件。如果已经硬 改过的，需要修改相应的文件来改变默认固件的大小。 还有新手在配置软件时，千万要注意一点，选择软件时会自动选上所依赖的文件，保存之后，下次再去除这个软件，所选的依赖文件并不会自动取消。这样会残留一些没有用的软件在固件里，对于空间非常小的闪存来说，这是很不应该的。所以配置一定要小心，弄好的配置做个备份。"},{"title":"lean大神LEDE(openwrt)编译教程","date":"2021-07-21T02:56:49.000Z","url":"/2021/07/21/lean%E5%A4%A7%E7%A5%9ELEDE-openwrt-%E7%BC%96%E8%AF%91%E6%95%99%E7%A8%8B/","tags":[["路由固件","/tags/%E8%B7%AF%E7%94%B1%E5%9B%BA%E4%BB%B6/"],["路由器编译","/tags/%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BC%96%E8%AF%91/"],["openwrt","/tags/openwrt/"]],"categories":[["openwrt系列","/categories/openwrt%E7%B3%BB%E5%88%97/"]],"content":"注意： 不要用 root 用户 git 和编译！！！； 编译前确保网络畅通； 默认登陆IP 192.168.1.1, 密码 password。 编译命令如下: 首先装好 Ubuntu 64bit， 命令行输入 sudo apt-get update ，然后输入 sudo apt-get install build-essential asciidoc binutils bzip2 gawk gettext git libncurses5-dev libz-dev patch unzip zlib1g-dev lib32gcc1 libc6-dev-i386 subversion flex uglifyjs git-core gcc-multilib p7zip p7zip-full msmtp libssl-dev texinfo libglib2.0-dev xmlto qemu-utils git clone  命令下载好源代码，然后 cd lede 进入目录4.输入以下源码 最后选好你要的路由，输入 make -j1 V&#x3D;s （-j1后面是线程数。第一次编译推荐用单线程）即可开始编译你要的固件了。 以后二次编译： 编译完成后固件输出在&#x2F;lede&#x2F;bin&#x2F;targets 编译切换内核： 打开LEDE目录&#x2F;target&#x2F;linux&#x2F;架构&#x2F;MakefileKERNEL_PATCHVER:&#x3D;4.9具体支持内核版本include&#x2F;kernel-version.mk 源码回退： files大法：就是把你 改好的配置 直接编译进固件这样做的好处就是升级不需要保留配置，或者恢复出厂设置，缺省值就是你自己设置好的配置固化某配置教程例子：1.提取路由固件下的etcconfignetwork2.在编译机LEDE根目录下创建files目录3.拷贝到filesetcconfignetwork这样编译完，network就是你自己配置好的network，注意提取的文件路径和权限要一致 一些常用的配置，路由器路径 etcconfig 各个LUCI配置etcgfwlist gfwlist目录etcshadow 登录密码etcfirewall.user 自定义防火墙规则usrshareadbyby adbyby里的相关规则和设置usrliblualuciviewadmin_statusindex.htm 主页样式文件，温度显示等等X86架构固件的index，默认被大雕files强奸了，自己到源码里替换&#x2F;lede&#x2F;package&#x2F;lean&#x2F;autocore&#x2F;files&#x2F;index.htm如果无效请make clean或者删除&#x2F;lede&#x2F;build_dir&#x2F;target架构&#x2F;autocore-1（编译其他失败同理）make package&#x2F;usb-modeswitch&#x2F;compile V&#x3D;99"},{"title":"openwrt编译入门","date":"2021-07-21T02:21:14.000Z","url":"/2021/07/21/openwrt%E7%BC%96%E8%AF%91%E5%85%A5%E9%97%A8/","tags":[["路由器编译","/tags/%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BC%96%E8%AF%91/"],["openwrt路由","/tags/openwrt%E8%B7%AF%E7%94%B1/"],["入门教程","/tags/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"]],"categories":[["openwrt系列","/categories/openwrt%E7%B3%BB%E5%88%97/"]],"content":"长话短说吧！写这篇文章是因为有些新入门的朋友，百度教程太多又五花八门看的雾里云里，是不是不知道怎么去编译属于自己的一个openwrt固件，这个教程就是为此设置的，有不对的请指出，谢谢 （如不清楚openwrt请先去度娘一下openwrt，不做多余解答） 第一步进入操作系统 ​ 第二步更新一下系统软件 ​ 第三步安装openwrt编译需要的环境 第四步下载openwrt 17.01 稳定版源代码 ​ 第五步更新软件 ​​ 第六步测试一下编译环境 make defconfig ​ 第七步开始我们的编译之旅 ​ ​ ​​ ​​​ 第八步也是最后一步生成固件 ​make -j8 download V&#x3D;s #下载dl库，编译成功率更高 make V&#x3D;99复制代码 ​ ​ 更新一下吧，关于openwrt编译中的误区，这也上了佐大的车才知道的，原来之前的操作有点傻逼，怪不得时好时坏 make -j4 V&#x3D;s ​ openwrt环境搭建脚本已经完成具体点击传送门 自己写的几篇小帖子不清楚的可以去看下 传送门 交流技术适当吹水群：667491026 （拒绝大爷公子伸手党）by：ITdesk2018年6月7日"},{"title":"openwrt编译笔记，有些技巧是自己试验出来的，很多人死也不肯说","date":"2021-07-21T02:11:48.000Z","url":"/2021/07/21/openwrt%E7%BC%96%E8%AF%91%E7%AC%94%E8%AE%B0%EF%BC%8C%E6%9C%89%E4%BA%9B%E6%8A%80%E5%B7%A7%E6%98%AF%E8%87%AA%E5%B7%B1%E8%AF%95%E9%AA%8C%E5%87%BA%E6%9D%A5%E7%9A%84%EF%BC%8C%E5%BE%88%E5%A4%9A%E4%BA%BA%E6%AD%BB%E4%B9%9F%E4%B8%8D%E8%82%AF%E8%AF%B4/","tags":[["路由器编译","/tags/%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BC%96%E8%AF%91/"],["openwrt编译","/tags/openwrt%E7%BC%96%E8%AF%91/"],["git版本","/tags/git%E7%89%88%E6%9C%AC/"]],"categories":[["openwrt系列","/categories/openwrt%E7%B3%BB%E5%88%97/"]],"content":"首先说一下几个坑：1.依赖libelf-dev，他们所有人的教程都没有libelf-dev这个（或者我记错了），当编译过程中盯着屏幕到中间时段会提示缺少依赖libelf-dev，跳过了某些模块的编译。编译出来的固件依然可用，但不知有什么问题。2.root分区，千万别设成128，256，512，1024这类死亡数值，反正不要设，会害死人。3.他们说的在编译前文件“设权限”，你们肯定不懂。起初我也不懂，后来摸索出来了：（其实在makefile里面也可以通过命令行设，只是动一下鼠标就好，何必写命令）普通权限（无执行权限，在WINSCP显示为，rw-r-r，即0644）：在ubuntu里，选择文件，右键菜单，在权限设置里依次选择：读写、只读、只读，并把“可作为程序运行”的选择框里所有可见的东西去掉。这样编译出来就是0644.执行权限（在WINSCP显示为，rwxr-xr-x，即0755）：在权限设置里依次选择：读写、只读、只读，并把“可作为程序运行”的选择框变成√。这样编译出来就是0755.二进制、sh、init.d里的启动文件都要设0755，不然无权限运行。在windows上复制进ubuntu里的文件，基本上权限都是离奇古怪的。可是先在windows上用winrar压缩成zip再复制进去然后解压，权限就会好好的变成0644。4.更改了某些package配置文件编译出来就是没改变？去make_dir搜索，把这文件夹移到回收站再编译（最好不要直接删除，不然删除了二进制文件你会被害死）。如果你直接删除了掉进坑了，编译过程中提示无某二进制文件，死也进行不了怎么办？妹的，删了特么就死也不重新编译了！怎么办？最傻的办法是make clean（我试过N次才知道这个办法乃下下策，要耗费大量时间重新编译），事实上只需要menuconfig里去掉这个package编译一次（只需要几分钟），然后又选上再编译就行了。make clean了可是得几个钟啊（你选了qbittorent的话你会生不如死）。。。（应该还有更好的办法，很明显是某缓存文件的问题，但我不知道）5.编译过程中最好不要ctrl+c终止，不然有时候你得到的结果就是make clean吧（因为某个还没完成的半拉子模块，下一次会被认为已完成，造成死也进行不下去了）！一旦开始编译，死也要进行到底。或者还有一个办法，同上面第4，去make dir删除，但问题是，往往它只是报错，并不告诉你是哪个模块错误。。。 ——————这里附上我自己编译的X86固件[-----------------]()系统更新 sudo apt-get update安装依赖关系 sudo apt-get install build-essential asciidoc binutils bzip2 gawk gettext git libncurses5-dev libz-dev patch unzip zlib1g-dev lib32gcc1 libc6-dev-i386 subversion flex uglifyjs git-core gcc-multilib p7zip p7zip-full msmtp libssl-dev texinfo libglib2.0-dev xmlto qemu-utils libelf-dev下载源码 git clone 进入目录： cd openwrt更新源： .&#x2F;scripts&#x2F;feeds update -a安装源： .&#x2F;scripts&#x2F;feeds install -a打开配置： make menuconfig打开内核配置：make kernel_menuconfig（一定要在file systems的Native language support设置好，不然网络共享文件名乱码）开工 make -j1 V&#x3D;s （-jn的n为电脑cpu的进程数） 非第一次编译cd openwrtgit pull.&#x2F;scripts&#x2F;feeds update -a &amp;&amp; .&#x2F;scripts&#x2F;feeds install -arm -rf .&#x2F;tmp &amp;&amp; rm -rf .configmake menuconfigmake kernel_menuconfigmake -j2 V&#x3D;s 没关闭终端的情况下简化为rm -rf .&#x2F;tmpmake menuconfigmake -j2 V&#x3D;s -—————————————————————————–git clone  ———-lean的git clone  ———-981213的git clone  ———-石像鬼的git clone  ———-Rosy的git clone  ———-官方的git clone  ———-官方的 想要18.06或其他老版本的，直接网页打开上面官方地址选18.06.2，下载压缩包来解压就可以了（以后不能用git pull命令，因为不是主支，需要git pull就要进行下面繁琐操作）：以V18.06.2为例：git clone  branch -a —-查看分支（如果直达18.06.2，这条和下面tag命令不需要）git tag —-查看版本git checkout v18.06.2 —-签出V18.06.2git pull origin v18.06.2 —-更新V18.06.2.&#x2F;scripts&#x2F;feeds update -a &amp;&amp; .&#x2F;scripts&#x2F;feeds install -a想要生成支持UEFI的映像文件，则还需要加上下面命令（来源于）：git remote add jow-staging  fetch jow-staginggit checkout -b uefi-capable –track origin&#x2F;master # so that you can rebase easilygit merge jow-staging-———-make kernel_menuconfig加入x86的多核心以及大内存支持Processor type and features —&gt; Symmetric multi-processing support Processor family (Core 2&#x2F;newer Xeon) —&gt;#自行选择处理器平* Supported processor vendors —&gt;#自行选择处理器平* (2) Maximum number of CPUs #自行编辑 SMT (Hyperthreading) scheduler support#超线程支持 Multi-core scheduler support High Memory Support (64GB) —&gt; 更改软件源：customfeeds.conf自定义源配置文件（在files大法改即可，文件在etc&#x2F;opkg下）科大的src&#x2F;gz openwrt_core  ... ets/x86/64/packagessrc&#x2F;gz openwrt_base  openwrt_luci  openwrt_packages  ... ges/x86_64&#x2F;packagessrc&#x2F;gz openwrt_routing  ... ages/x86_64&#x2F;routing distfeeds.conf 官方源配置文件（在files大法改即可）官方的src&#x2F;gz openwrt_core  openwrt_base  openwrt_luci  openwrt_packages  openwrt_routing  openwrt_telephony  源问题下载不了模块中途编译终止没问题，按上箭头键重新输入上一个命令重来。所有东西都乱了，无药可救了怎么办？移出&#x2F;openwrt&#x2F;的dl文件夹，然后把整个openwrt删除，再git clone一次，把dl移入，重新来过，可以节省很多下载模块时间。或者执行下面命令。make clean 仅仅是清除之前编译的可执行文件及配置文件，比如bin路径下面的文件，config配置文件不会清除。make distclean 清除所有生成的文件，连feeds也会干掉，只留下git clone完成时候的初始状态。 技巧1：连移动卡的手机热点下载模块要比电信宽带快得多哦！！！！！！ 2：files大法，不用去修改源码就可以自定义配置固化到固件中，比如要经常刷固件、做ramdisk版，不用每次都升级备份文件。刷第一次安装配置好APP等。用scp进入根目录，把整个etc目录搬下来。在openwrt目录建立file目录。把etc放进去，然后进etc翻看，有用的留下，没用的删除，ok！编译好之后大部分配置都在。如果你只是在自己主板上用，什么都可以留下。如果你要发给人家或者换机型，则里面所有有MAC地址、UUID识别码或者其它固定硬件识别码的文件都得删掉（比如wireless就有MAC地址），不然会产生灵异事件。 3：单独编译某个模块比如v2瑞，要先在make menuconfig里面luci app相应的v2瑞-pro打上Mmake package&#x2F;lean&#x2F;luci-app-v2瑞-pro&#x2F;compile 4：碰到一个玩意硬是wget不了怎么办？把出错提示的地址复制下来，用浏览器，迅雷，什么都行，下载好扔进dl目录（如果不是dl目录的有提示，并且此方法无效）比如这个变态的kcptun-linux-amd64-20181002.tar.gz，问了度娘之后在下面地址找到。 -——————————————————————————源更新不了，opkg被神经病锁定不能安装app，删除&#x2F;var&#x2F;lock&#x2F;opkg.lock 自己替换“总览”页面&#x2F;feeds&#x2F;luci&#x2F;modules&#x2F;luci-mod-status&#x2F;luasrc&#x2F;view&#x2F;admin_status&#x2F;index.htm 压缩虚拟盘cd C:\\Program Files (x86)\\VMware\\VMware Workstationvmware-vdiskmanager.exe -k “G:\\Ubuntu\\Ubuntu 64 位.vmdk” -——————————————————————————1）修改登录密码（可以用files大法，文件在&#x2F;etc下的shadow，在“管理权”设置好密码，直接SCP备份shadow文件，以下各项同样方法配制）修改shadow文件，位于package&#x2F;base-files&#x2F;files&#x2F;etcroot1$BuM.Ox4e$X&#x2F;RX2ftRaBzzVzoL6TkI0&#x2F;:17943:0:99999:7::: —————-root后面的两个root：：17943之间一串乱码就是加密后的密码（需要在“管理权”设置好SCP上去打开复制下来，不能直接填入明文），此处示例为admin。-—2）修改路由连接数（可以用files大法，文件在ect下的sysctl.conf）修改sysctl.conf文件，位于package&#x2F;base-files&#x2F;files&#x2F;etcnet.netfilter.nf_conntrack_max&#x3D;262144 -—3）默认中文feeds&#x2F;luci&#x2F;libs&#x2F;web&#x2F;root&#x2F;etc&#x2F;config 1option（可以用files大法，其实不用管，只要时区改了并且添加了中文luci，会自动使用中文）lang auto改为 1option lang zh_cn 并添加config internal languages ​ option en ‘English’ ​ option zh_cn ‘chinese’ -—4）修改默认主题（用files大法无效）修改feeds&#x2F;luci&#x2F;libs&#x2F;web&#x2F;root&#x2F;etc&#x2F;configoption mediaurlbase &#x2F;luci-static&#x2F;openwrt.org可根据需要将openwrt.org修改为Bootstap、openwrtcn、freifunk-bno、freifunk-generic -—5）修改主机名、设定时区（可以用files大法，文件在&#x2F;etc&#x2F;config下的system）修改package&#x2F;base-files&#x2F;files&#x2F;etc&#x2F;config&#x2F;systemoption hostname Openwrt ———-主机名option timezone Asia&#x2F;Shanghai———-时区设置为亚洲&#x2F;上海option timezone CST-8 ———-正8区 -—6）默认lan ip地址配置（本机使用可以用files大法，在ect下面找同名文件）package&#x2F;base-files&#x2F;files&#x2F;bin&#x2F;config_generate搜索192.168定位到下面字段配置。set network.$1.ipaddr&#x3D;’192.168.1.1’set network.$1.netmask&#x3D;’255.255.255.0’ -—7）更改openwrt后台web登陆用户名方法1.修改&#x2F;etc&#x2F;passwd将root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;ash修改为username:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;ash。 2.修改&#x2F;etc&#x2F;shadow将root:xxxxxx:0:0:99999:7:::修改为username:xxxxxx:0:0:99999:7:::。 3.修改&#x2F;usr&#x2F;lib&#x2F;lua&#x2F;luci&#x2F;controller&#x2F;admin&#x2F;index.lua将page.sysauth &#x3D; {“root”}修改为page.sysauth &#x3D; {“username”}。 4.修改&#x2F;usr&#x2F;lib&#x2F;lua&#x2F;luci&#x2F;controller&#x2F;admin&#x2F;servicectl.lua将entry({“servicectl”}, alias(“servicectl”, “status”)).sysauth &#x3D; {“root”}修改为entry({“servicectl”}, alias(“servicectl”, “status”)).sysauth &#x3D; {“username”}。 -—默认wifi系列（本机使用可以用files大法，文件是etc&#x2F;config下wireless）修改的文件为 &#x2F;trunk&#x2F;package&#x2F;kernel&#x2F;mac80211&#x2F;files&#x2F;lib&#x2F;wifiset wireless.radio${devidx}&#x3D;wifi-deviceset wireless.radio${devidx}.type&#x3D;mac80211set wireless.radio${devidx}.channel&#x3D;1 ——-指定频道set wireless.radio${devidx}.hwmode&#x3D;11g ——-指定11g模式set wireless.radio${devidx}.country&#x3D;CN ——-指定国家set wireless.radio${devidx}.htmode&#x3D;HT40 ——-40MHz带宽（单改无效，还需要改上面iw phy “$dev” info | grep -q ‘Capabilities:’ &amp;&amp; htmode&#x3D;HT40）set wireless.radio${devidx}.legacy_rates&#x3D;1set wireless.radio${devidx}.noscan&#x3D;1 ——-强制40MHz带宽（默认无，需要添加）${dev_id}${ht_capab}set wireless.radio${devidx}.disabled&#x3D;0 ——–改为0默认开无线 set wireless.default_radio${devidx}&#x3D;wifi-ifaceset wireless.default_radio${devidx}.device&#x3D;radio${devidx}set wireless.default_radio${devidx}.network&#x3D;lanset wireless.default_radio${devidx}.mode&#x3D;apset wireless.default_radio${devidx}.ssid&#x3D;IOU ———指定SSIDset wireless.default_radio${devidx}.encryption&#x3D;psk2+ccmp ———指定加密模式set wireless.default_radio${devidx}.key&#x3D;13143344 ———指定密码（默认无，需要添加） -—8）整理web管理上面APP出现的菜单位置比如把一个出现在“服务”菜单里的app改到“网络”里，以NFT-QOS为例：进入package下面的luci-app-nft-qos&#x2F;controller,看到nft-qos.lua文件，打开看到：entry({“admin”, “services”, “nft-qos”}, cbi(“nft-qos&#x2F;nft-qos”),上面的”services”就是“服务”，修改为”network”,这个app就会改变到“网络”菜单里了。 -—我要出去工作了，没时间玩了，最后给你们一个东西，这个东西来源于lean(抱歉，我拿来用了），可以编译时加载默认设置和加一些额外的翻译词组。我精简了一些官方源码用不到的项，只留下上面说到那些基本设置，然后加上了一些我自己需要的设置项。解压后放到package下面，然后在make menuconfig&#x2F;luci里打开default settings这个选项就可以了，上面提到的大部分设置都可以在这package的files&#x2F;zzz-default-settings里面修改的，不用再一个个model去修改，自己研究吧。 default-settings.rar (26.76 KB, 下载次数: 267) 增加了一些项的default-settings.tar.xz.zip (21.91 KB, 下载次数: 247) 20191009补充：8）整理web管理上面APP出现的菜单位置比如把一个出现在“服务”菜单里的app改到“网络”里，以NFT-QOS为例：进入package下面的luci-app-nft-qos&#x2F;controller,看到nft-qos.lua文件，打开看到：entry({“admin”, “services”, “nft-qos”}, cbi(“nft-qos&#x2F;nft-qos”),上面的”services”就是“服务”，修改为”network”,这个app就会改变到“网络”菜单里了。————–某些比较复杂关系的app只修改这一处会无法运行，是因为多个函数使用了这个路径，需要一一修改。luasrc下面所有文件都要打开查找一遍，凡是存在“services”这个一路径的（或者是admin&#x2F;services&#x2F;xxx这样的路径的），通通需要替换成“network”才算完成。lean的defaultsetting有这些lua重分配命令，但是同样存在上面的问题，所以必须从源码本身去修改。"},{"title":"新路由3 编译 Openwrt 固件","date":"2021-07-13T16:44:26.000Z","url":"/2021/07/14/%E6%96%B0%E8%B7%AF%E7%94%B13-%E7%BC%96%E8%AF%91-Openwrt-%E5%9B%BA%E4%BB%B6/","tags":[["OpenWrt","/tags/OpenWrt/"],["固件编译","/tags/%E5%9B%BA%E4%BB%B6%E7%BC%96%E8%AF%91/"],["路由器刷机","/tags/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%88%B7%E6%9C%BA/"]],"categories":[["openwrt系列","/categories/openwrt%E7%B3%BB%E5%88%97/"]],"content":"希望有一个包含 ssr plus+ 的 Openwrt 固件，但是这样的固件往往有很多我不需要的功能，而且有被植入后门的风险，所以还是自己编译了一个。 其实一个更重要的理由就是我想要 NAT1，也就是 fullcone NAT，于是只能自己编译。 目标为自家的 新路由3 编译一个固件，然后白嫖 GitHub Action 进行编译。 需要的额外功能有：SFE 快速转发，SSR，ZeroTier 最后要求能 Full Cone Nat (Nat 1)，主要是用来打游戏啦。 准备环境按照要求开一个 ubuntu 18.04 的虚拟机或者 Docker（肯定是 Docker 方便，但是不熟悉 Docker 的话还是虚拟机吧）。 配置好代理（白名单或者全局），否则下载可能会很慢。 如果是虚拟机： 记得预留 30G 以上的空间，不然会编译失败（可能是我编译线程数开得太多了，导致临时文件过多）。 内存 5G 以上。 首次编译按照  操作。 注： clone 仓库后，把 lede&#x2F;feeds.conf.default 的 hello world 那行取消注释，解锁对于国内用户最重要的功能。 对于新路由3，Target 的配置 MediaTek Ralink MIPS - MT7621 base boards - Newifi D2 我额外开启的 luci app 为：sfe, ssr plus, zerotier, unblock-netease-music 开启 NAT 1按照  操作。 对于最新版本的 openwrt (kernel 为 Linux 5.4)，编译时会报错，解决方案 issue 里有提到  。 要让它生效，需要在 iptables 的自定义规则中加入以下两行，网络接口的名字 eth0 可能需要替换。 测试 NAT 类型可以用这个： 集成 GitHub Action 有详细的教程，大概就是 clone 出来，把本地 .config 文件传上去，再按需修改 diy part 1 &amp; 2 就好了。 自带的 diy part 1 可以解锁 hello world 以及增加 lienol 源，diy part 2 可以配置初始的 ip 地址。 把 NAT 1 补丁加在 diy part 1 中。 编译时间大概两小时不到，手动触发（所以也不算浪费资源吧），最后贴上仓库地址  供参考。"},{"title":"Hexo使用攻略-添加分类及标签","date":"2021-07-13T16:03:06.000Z","url":"/2021/07/14/Hexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/","categories":[["HEXO系列","/categories/HEXO%E7%B3%BB%E5%88%97/"]],"content":"本教程针对的是Mac环境下，nexT主题的文章分类和标签设置，其他主题也应该是类似的。添加成功后会在侧边栏或导航栏生成“分类”和“标签”这两个选项，看下图： 点击“分类”后的页面： 点击“标签”后的页面： ok，大概效果就是这样的，下面进入教程 1、创建“分类”选项1.1 生成“分类”页并添加tpye属性打开命令行，进入博客所在文件夹。执行命令 成功后会提示： 根据上面的路径，找到index.md这个文件，打开后默认内容是这样的： 添加type: &quot;categories&quot;到内容中，添加后是这样的： 保存并关闭文件。 1.2 给文章添加“categories”属性打开需要添加分类的文章，为其添加categories属性。下方的categories: web前端表示添加这篇文章到“web前端”这个分类。注意：hexo一篇文章只能属于一个分类，也就是说如果在“- web前端”下方添加“-xxx”，hexo不会产生两个分类，而是把分类嵌套（即该文章属于 “- web前端”下的 “-xxx ”分类）。 至此，成功给文章添加分类，点击首页的“分类”可以看到该分类下的所有文章。当然，只有添加了categories: xxx的文章才会被收录到首页的“分类”中。 2、创建“标签”选项2.1 生成“标签”页并添加tpye属性打开命令行，进入博客所在文件夹。执行命令 成功后会提示： 根据上面的路径，找到index.md这个文件，打开后默认内容是这样的： 添加type: &quot;tags&quot;到内容中，添加后是这样的： 保存并关闭文件。 2.2 给文章添加“tags”属性打开需要添加标签的文章，为其添加tags属性。下方的tags:下方的- jQuery - 表格- 表单验证就是这篇文章的标签了 至此，成功给文章添加分类，点击首页的“标签”可以看到该标签下的所有文章。当然，只有添加了tags: xxx的文章才会被收录到首页的“标签”中。 细心的朋友可能已经发现，这两个的设置几乎一模一样！是的，没错，思路都是一样的。所以我们可以打开scaffolds&#x2F;post.md文件，在tages:上面加入categories:,保存后，之后执行hexo new 文章名命令生成的文件，页面里就有categories:项了。 scaffolds目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值。 教程结束，赶紧去设置吧！"},{"title":"NEWIFI 3 | 新路由3 D2 刷OpenWrt教程","date":"2021-07-12T17:59:52.000Z","url":"/2021/07/13/NEWIFI-3-%E6%96%B0%E8%B7%AF%E7%94%B13-D2-%E5%88%B7OpenWrt%E6%95%99%E7%A8%8B/","categories":[["openwrt系列","/categories/openwrt%E7%B3%BB%E5%88%97/"]],"content":"NEWIFI 3 | 新路由3 D2 刷OpenWrt教程 2021.01.24 newifi3 4 7 4390 目录 一、准备工具1.newifi D2 OpenWrt 固件（VLEDE1.4.1）2.下载MobaXterm 工具二、newwifi 3 D2 开启 SSH三、MobaXterm 连接 D2 SSH四、备份原始固件五、刷入vlede1.4.1固件 收藏 2 一、准备工具1.newifi D2 OpenWrt 固件（VLEDE1.4.1）VLEDE1.4.1 NEWIFI固件 2.下载MobaXterm 工具newifi-d2-jail-break.ko SSH驱动 二、newwifi 3 D2 开启 SSHLAN口 连接电脑，本地IP地址设置 192.168.99.10 浏览器打开  看到返回success 说明开启SSH 三、MobaXterm 连接 D2 SSH把newifi-d2-jail-break.ko 上传到 tmp文件夹然后运行2条命令 开始刷入Bread，刷写完成后路由器将自动重启当灯灭时可以把路由器电源拔掉 按住路由器的RESET键不放，插入电源，几秒后五灯闪亮一下松开RESET键本地IP地址设置为 192.168.1.10浏览器打开 192.168.1.1 即可进入breed Web恢复控制台 四、备份原始固件建议将newifi3原版固件和EEPROM备份一下在【固件备份】中可以将固件下载备份到电脑中 五、刷入vlede1.4.1固件 转载原创文章请注明，转载自: Vedio Talk - NEWIFI 3 | 新路由3 D2 刷OpenWrt教程 ()"},{"title":"hexo增加个性插件","date":"2021-07-12T17:39:49.000Z","url":"/2021/07/13/hexo%E5%A2%9E%E5%8A%A0%E4%B8%AA%E6%80%A7%E6%8F%92%E4%BB%B6/","categories":[["HEXO系列","/categories/HEXO%E7%B3%BB%E5%88%97/"]],"content":" 第四波攻势来临啦~还是对hexo-next做优化、美化♣️这次我想加入折叠功能、鼠标放置后图片放大、分类和标签界面显示年份、可爱的十二生肖、分类层级显示、文章阅读后评分、侧栏加音乐 Todo list: 折叠功能 鼠标放置后图片放大 分类和标签界面显示年份 年份后显示十二生肖 分类&amp;标签层级显示 文章阅读后评分 侧栏加音乐 live2d看板娘 推荐两个emoji的复制网站 让我为你点一首歌吧！♪\b一直陪着你ヾ(·▽·ヾ)开始静静享受\b歌曲吧！ Clsr (Aash Mehta Flip) - The Chainsmokers &#x2F; Aash Mehta &#x2F; Halsey Hey, I was doing just fine before I met you (嘿 遇到你之前我一切安好) I drink too much and that’s an issue but I’m okay (虽酩酊大醉 看上去一团糟 但我感觉很好) Hey, you tell your friends it was nice to meet them (嘿 告诉你的朋友很高兴和他们相遇) But I hope I never see them again (但我希望再也看不到他们的身影) I know it breaks your heart (我知道这会伤了你的心) Moved to the city in a broke down car (驾着一辆破汽车 驶向一座陌生的城市) And four years, no calls (一去四年 杳无音讯) Now you’re looking pretty in a hotel bar (现在你的美貌闪耀在酒吧的聚光灯下) And I can’t stop, no, I can’t stop (我忍俊不禁浮想联翩) So baby pull me closer in the backseat of your Rover (宝贝 同我咫尺之遥 在你后座上耳语呢喃 如胶似漆) That I know you can’t afford (缠绵于这辆永远付不起的路虎车上) Bite that tattoo on your shoulder (让我的舌尖滑过你肩上的纹身) Pull the sheets right off the corner (迫不及待的推开车里的钢板) Of the mattress that you stole (放上舒适的床垫让你我共缠绵) From your roommate back in Boulder (那张你从博尔德的室友那偷来的床垫) We ain’t ever getting older (今夜我们激情永葆) You look as good as the day I met you (回首过去我遇到你的那日多美好) I forget just why I left you, I was insane (我也忘记我为何离你而去 大概是脑子一热) Stay and play that Blink-182 song (彻夜未眠 放着Blink-182（乐队）的歌) That we beat to death in Tucson, okay (那曲我们曾在图森恣意敲打的节奏) I know it breaks your heart (我知道这会伤了你的心) Moved to the city in a broke down car (驾着一辆破汽车 驶向一座陌生的城市) And four years, no calls (一去四年 杳无音讯) Now I’m looking pretty in a hotel bar (现在我的闪耀在酒吧的聚光灯下) And I can’t stop (我忍俊不禁) No, I can’t stop (浮想联翩) So baby pull me closer in the backseat of your Rover (宝贝 同我咫尺之遥 在你后座上耳语呢喃 如胶似漆) That I know you can’t afford (缠绵于这辆永远付不起的路虎车上) Bite that tattoo on your shoulder (让我的舌尖滑过你肩上的纹身) Pull the sheets right off the corner (迫不及待的推开车里的钢板) Of the mattress that you stole (放上舒适的床垫让你我共缠绵) From your roommate back in Boulder (那张你从博尔德的室友那偷来的床垫) We ain’t ever getting older (今夜我们激情永葆) Baby pull me closer in the backseat of your Rover (宝贝 同我咫尺之遥 在你后座上耳语呢喃 如胶似漆) That I know you can’t afford (缠绵于这辆永远付不起的路虎车上) Bite that tattoo on your shoulder (让我的舌尖滑过你肩上的纹身) Pull the sheets right off the corner (迫不及待的推开车里的钢板) Of the mattress that you stole (放上舒适的床垫让你我共缠绵) From your roommate back in Boulder (那张你从博尔德的室友那偷来的床垫) We ain’t ever getting older (今夜我们激情永葆) We ain’t ever getting older (no we ain’t ever getting older) (我们的青春永不褪色…) We ain’t ever getting older (no we ain’t ever getting older) (我们的青春永不褪色…) We ain’t ever getting older (we ain’t ever getting older) (我们的青春永不褪色…) We ain’t ever getting older (no we ain’t ever getting older) (我们的青春永不褪色…) 00:00 &#x2F; 00:00 折叠功能有大段的东西想要放上去，但又不想占据大量的位置。折叠是最好的选择。2 (其实也可以用tabs功能，请看3) 下面在Hexo的主题上定制添加折叠功能。next主题的主要js位于themes/next/source/js/src/post-details.js,在里面找合适的位置，添加如下代码： 复制 在主题的scripts下添加一个tags.js, 位于themes/next/scripts/tags.js 复制 再继续添加一个fold.js: 复制 最后，添加几个自定义样式， 复制 使用方法：在我们需要折叠的地方前后添加便签，示例用法： 复制 分类和标签界面显示年份修改分类年份打开 \\themes\\next\\layout\\category.swig 查找 复制 改为 复制 添加 复制 修改标签年份打开\\themes\\next\\layout\\tag.swig查找: 复制 改为: 复制 添加 复制 修改分类&amp;标签层级显示分类层级在\\themes\\next\\layout\\_macro\\post.swig查找1： 复制 将其改为 复制 \b则显示如下： 标签层级在\\themes\\next\\source\\css\\_custom\\custom.styl中添加: 复制 则显示如下： 侧栏加音乐「aplayer」 打开 \\themes\\next\\source\\js\\src\\custom\\ 放置 APlayer.min.js复制这个页面的内容 打开 \\themes\\next\\layout\\_custom\\在 sidebar.swig写入 复制 live2d看板娘:star2:像我博客右下角的小人，有至少三种以上的方式，就来按照从简单到难、从随波逐流到自定义来\b介绍吧！ 直接引用没错，就是直接引用别的大大的【看板娘】，他们已经写好了代码，我们就不需要再写、添加到文件夹里面的，只需要在themes/next/layout/_custom/head.swig里面添加这些代码，就是引用了。 优点是简单、方便，推荐如我一样的小白，或者只需要最基础的功能的朋友使用缺点是自定义程度小，比如我想修改看板娘说的话等等，都很难。 复制 安装插件hexo-next有一个插件，这里是安装live2d的插件！安装就可以用了。这里插件很多哟！ 优点是相对来说比较简单，可以换模型缺点是插件不带对话等功能，就相当于一个\b不会说话的漂亮娃娃\b然鹅，一个不会说话、表达的娃娃怎么比得上会聊天、会撩的看板娘呢？？？所以，我就\b使劲折腾着…… 自定义下载大佬[3]的文件后，自己去折腾吧（╭(╯╰)╮我才不会告诉你，我个小白折腾了好久，虽然有成功过，但是最后发现加载太坑了我对自定义已经不抱太大希望了！） 推荐几枚大佬：    优点是自定义程度大，推荐有丰富代码经验的人食用\b缺点是\b会导致博客加载速度过慢 emoji🤕🤜🏻😹🤑👿表😬🙄👽🤝情🤤🤐👻😅🤯帝😧☠😦😂我看到有人会安装插件，然鹅，我的不需要安装插件也可以使用emoji，可能大家也不需要安装那些emoji插件哦！\b所以，看到喜欢的、想用emoji，可以到下面的网站去copy哦！不过，我的网站显示的emoji可能会不同别太介意啦   1.[ ↩]() 2.[ ↩]() 3.[ ↩]() 本文结束咯(oﾟ▽ﾟ)o感谢您的阅读 欢迎你来阅读相关文章哦(๑•̀ㅂ•́)و✧ 用HEXO打造更个性化的个人博客1 用HEXO打造更个性化的个人博客2 用HEXO打造更个性化的个人博客3 英文论文借鉴句子 学习一种新的语言吧！HTML学习记录笔记（二） 学习一种新的语言吧！HTML学习记录笔记（一） 学习CSS自定义样式，让博客焕然一新（四） 学习CSS自定义样式，让博客焕然一新（三） 本文作者： 欧萌 本文链接：  版权声明： 本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！ "},{"title":"Hexo为文章添加分类","date":"2021-07-12T17:25:05.000Z","url":"/2021/07/13/Hexo%E4%B8%BA%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB/","tags":[["Hexo技巧","/tags/Hexo%E6%8A%80%E5%B7%A7/"],["Hexo插件","/tags/Hexo%E6%8F%92%E4%BB%B6/"]],"categories":[["HEXO系列","/categories/HEXO%E7%B3%BB%E5%88%97/"]],"content":"hexo next 添加分类页 新建一个页面，命名为 categories 。命令如下： 编辑刚新建的页面，将页面的类型设置为 categories ，主题将自动为这个页面显示所有分类。 注意：如果有启用多说 或者 Disqus 评论，默认页面也会带有评论。需要关闭的话，请添加字段 comments 并将值设置为 false，如： 在菜单中添加链接。编辑主题的 _config.yml ，将 menu 中的 categories: &#x2F;categories 注释去掉，如下: 但是这样部署之后，在分类页面还是看不到任何分类的，同时官方的next教程中并没有写。。其实为文章添加分类关联的教程已经在hexo教程给出了。。下面仅仅做个简单的介绍，全面的教程参照hexo官方教程(需备梯子) 添加文章分类关联 hexo中有Front-matter这个概念，是文件最上方以 — 分隔的区域，用于指定个别文件的变量。举个栗子，在hexo new post article时会生成article.md文件，文件生成好的文章属性。 在其中添加categories属性，再部署之后就可以在分类页看到分类了 "},{"title":"Hexo安装使用技巧","date":"2021-07-12T15:54:12.000Z","url":"/2021/07/12/Hexo%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/","categories":[["HEXO系列","/categories/HEXO%E7%B3%BB%E5%88%97/"]],"content":"目录一、准备工作二、搭建博客(远程与本地)三、发布博客四、更换主题五、博客网站美化六、在不同电脑管理hexo博客七、遇到问题八、其他方案 一、准备工作1.了解HexoHexo是高效的静态站点生成框架，她基于Node.js。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的标签插件来快速的插入特定形式的内容，而且相对于其他框架，Hexo在速度上也有很大优势。 2.搭建Node.js环境我们了解到Hexo基于Node.js的，那么我们搭建博客网站首先需要安装Node.js环境。 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，可以在非浏览器环境下，解释运行 JS 代码。下载地址：测试安装：命令行使用node -v 、mpm -v，查看显示版本号即成功。 3.安装Hexo博客框架工具Hexo是一个建站工具，可以帮助我们快速生成基本的博客文件，安装它需要在控制台下使用如下命令： npm install hexo-cli -g1若报错，请尝试在命令前加上sudo 4.安装Git版本工具Git是目前世界上最流行的分布式版本控制系统，是的，没有之一。使用Git可以帮助我们把本地的网页和文章等内容提交到Gihub上，实现同步。下载地址：系统需下载，Mac系统因为自带Git无需操作。测试安装：git - -version，查看显示版本号即成功。 5.注册Github账号gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。这里用到Github，是因为我们需要通过Github得到自己的博客网站域名，而且需要使用gitHub同步我们个人博客的相关文件。注册地址：注册流程：，百度一下，你就知道啦。 注意：注册Github的时候一定要选择一个合适的名字，因为后来博客网站的域名也会用到这个名字。虽然Github用户名支持后期修改，但是还是会带来很多不必要的麻烦。github的使用在网上有很多教程，这里也就不再累述了。 二、开始搭建博客1.开启GitHub Pages服务搭建我们的个人博客需要一个唯一的域名，当然我们可以申请购买一个域名来使用，但是在不是太必要的情况下，我们也可以通过Github Pages获得一个免费使用的域名，这需要我们在Github上新建一个仓库，如下： 这个过程和建立普通的仓库没什么区别，关键在于新仓库的名字，一定要是UserName+“github.io”的形式。这也是之前强调的要起一个好的用户名的原因。这样之后我们最后的博客网站的链接就会是：的形式。注意：固定新仓库的名字格式并非必须，只是这样操作生成的博客域名比较短小简洁，另起他名生成博客域名会很冗长。 点击Create Repository之后，随后选择Setting进入设置，找到Github Pages如下： 这里我们需要点击Choose a theme任意选择一个选择主题，然后界面会跳转到仓库，我们看到有两个文件如下： 此时若再查看setting，我们会看到开启GitHub Pages之后得到的域名如下： 现在，我们就可以使用，访问自己的博客网站了，打开链接我们会看到默认主题的个人博客样式如下(虽然有点点丑，是吧)： 2.创建本地博客站点上述的步骤相当于我们使用Github page，创建了一个默认的博客页，并且得到了一个可外部访问的域名。但是这个博客页很Low。我们的目的是创建自己个性化的博客网站，所以我们使用Hexo在本地先创建一个本地博客站点，优化后再把它部署到github上。接下来我们使用控制台命令在本地一个合适的位置创建博客站点文件夹如下： hexo init myHexoBlog &#x2F;&#x2F;myHexoBlog是项目名1 下面来测试本地博客站点，在本地博客根目录下使用控制台命令： hexo g &#x2F;&#x2F;g是generetor的缩写，生成博客 hexo s &#x2F;&#x2F;s是server的缩写，启动服务123此时打开浏览器，输入 ，我们将会看到Hexo自带默认主题显示的博客样式如下(呃，是好看了那么一点点)： 3.同步Github,允许公共访问在本地我们已经搭建了博客，但是还只能自己本地访问。若要别人也能看到，那就需要我们将其同步部署到GitHub上了。还记得我们之前准备的Github仓库吗，这里就要用到了。首先找到我们的博客仓库，并拷贝仓库地址： 然后修改本地博客目录的配置：修改本次博客根目录下的_config.yml文件，修改deploy下的配置如下： 最后执行控制台命令： npm install hexo-deployer-git —save &#x2F;&#x2F;安装部署插件hexo d &#x2F;&#x2F;部署到github12现在，我们再次访问链接：，就会发现这里的界面和本地的一样了。如此一来我们搭建的个人博客网站就基本完成了。 三、发布博客激动人心的时候到了，终于可以发布自己的第一篇博客了。来尝试一下以下的步骤：在本地博客文件夹根目录输入： hexo new “我个人博客的第一篇博客，哈哈哈…” hexo g &#x2F;&#x2F;生成网页 hexo d &#x2F;&#x2F;部署到远端(github)12345查看我们本地的博客文件夹，将会看到我们创建一个条新的博客文章： 现在打开我们的博客网站：,会看到网页如下(显示可能会延时，不如先喝杯茶放松下吧)： 这就是我们发布博客的方法啦，当然这里是为了演示，真正做的时候我们要找到_posts里的博客原文，先编辑内容，然后再部署到github上。 四、更换主题现在我们已经看见个人博客的雏形了，但是现在的博客网页一点也不高大上。为了让它看起来更美观一些，我们可以为其更换主题（当然也可以自己在默认主题下自己编写美化博客界面，可是我还不太会前端，以后再突破吧）。这里以使用github上的next主题为例： 1.创建next文件夹切换到本地博客根目录下，在主题文件thems下创建一个新文件夹next存放即将下载的next主题 mkdir themes&#x2F;next12.下载主题Nextcurl -s  | grep tarball_url | cut -d ‘“‘ -f 4 | wget -i - -O- | tar -zx -C themes&#x2F;next –strip-components&#x3D;11此步骤可参考： 下载成之后我们会看到next的主题已经存在thems里了如下： 3.修改博客配置文件，更换主题配置修改博客根目录(不是next主题)下的_config.yml文件，搜索theme字段，并将其值修改为next。 然后在控制台下输入如下命令： hexo clean &#x2F;&#x2F;清理缓存 hexo g &#x2F;&#x2F;重新生成博客代码 hexo d &#x2F;&#x2F;部署到本地12345再次打开我们的博客网站：，将会看到更换主题后的博客网页如下： 五、博客网站美化终于我们的博客也算像点样子了，如果你和我一样是个完美主义者，那我们来继续美化它吧。这需要我们对博客中的各种配置进行修改。 首先说明一下：在Hexo中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 1.站点配置：在本地的博客根目录下找到_config.yml，用编辑器打开，如下： 这里可以修改博客网站的标题、描述，语言等属性，上面更换主题也是在这个文件中修改的。大家可以在这里稍作设置。 2.主题设置关于博客主题的配置这块本来想着自己写下呢，却发现官方文档更加详尽。大家可以参考Next文档来学习。文档地址：其他参考：hexo的next主题个性化教程打造个性超赞博客Hexo+Next+githubPages的超深度优化 3.更多主题选择next只是众多Hexo主题的一种，还有很多优秀的主题可供我们选择，参考以上的更换及配置方法我们就可以进一步美化我们的个人博客网站了。更多主题选择： 六、在不同电脑管理hexo博客其实，这也是我在使用Hexo搭建博客遇到的一个问题，如果我们检查自己博客在Github上的文件就会发现，github仓库里的文件和我们本地博客站点的文件夹是不同的，确切来说是少了很多内容。如果我们想在不同的电脑上管理自己的博客，就必须有源文件存在远端供我们随时下载、然后修改后重新部署到远端。 我们要理解这样一个过程：hexo -d是把本地博客源文件生成的静态网页文件同步到github上，实现部署。但是博客网站的源文件仍需要我们自己保存。这里主要有两种思路可以选择： 1.在github存放我们博客静态网页文件的仓库里另建分支brach，单独用于存放源文件。2.将本地博客文件存放在码云上。 这些都是关于git的操作，所以这里不用细说了。单对于这两种方法来说，我更倾向于第二种。因为毕竟这些都是我们搭建个人博客的源文件，将来还要在网站上发表文章，很多数据都在这里。使用码云我们可以创建私有仓库，将这些源文件私有存放更好一些，而且源文件和静态博客网页文件分开存放也避免使用分支频繁切换。 七、遇到问题1.修改了配置，网站没有变化这种情况，大多因为修改后配置后我们直接部署，没有执行hexo clean。 2.代码无法高亮显示在Hexo的next主题下，我们使用markDown编辑文章，如果代码无法高亮，这有可能是我们没有在标记语言后添加语言类型，我需要在添加代码片段的时候使用如下的样式： ————————————————版权声明：本文为CSDN博主「梧雨北辰」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接："},{"title":"KIW-AL10（全网通）线刷+卡刷","date":"2021-07-08T09:32:33.000Z","url":"/2021/07/08/KIW-AL10%EF%BC%88%E5%85%A8%E7%BD%91%E9%80%9A%EF%BC%89%E7%BA%BF%E5%88%B7-%E5%8D%A1%E5%88%B7/","categories":[["玩机技巧","/categories/%E7%8E%A9%E6%9C%BA%E6%8A%80%E5%B7%A7/"]],"content":" 喜欢搞机的，真是不见官财不掉泪； 只要开机一震后能亮，能进fastboot救援界面并且： Phone UnLocked ，那就有的救——此教程以KIW-AL10机型亲测以下两种情况： EMUI 4.0 B407 回退 Emui 3.1 B180（之前是从 B180 OTA 更新 B407的情况），然后只能更新B407； 在更新B410后，只能线刷Hisuite下载的 B191回退 包（不是官网发布的B191固件），然后也只可再次更新B410。 更新412，415后，没有再尝试此教程中的操作；但使用hisuite回退，412-191回退包，和410-191回退包，MD5值不同，表明，回退包不同！因而，提醒机友，非特殊情况，不建议如此这般强制回退，以免造成后期无法升级的问题。 一、官方固件包准备：荣耀畅玩5X全网通版（KIW-AL10）荣耀畅玩5X全网通DM定制版（KIW-AL10）荣耀畅玩5X移动版（KIW-TL00H）荣耀畅玩5X移动定制版（KIW-TL00）荣耀畅玩5X电信版（KIW-CL00）荣耀畅玩5X双4G版（KIW-UL00） 下载后，解压缩，我们得到自己所用机型的update.app 二、UPDATE.APP解包： 我们需要这几个镜像文件： boot.img recovery.img system.img cust.img先把它们提取到一个文件夹内，一会都有用~ 三、CUST单刷包制作：boot.img，system.img，recovery.img都能够通过线刷完成； 但不知道为啥？cust.img被拒绝刷入。当然，这样线刷完后，没有定制信息（当然也没有那些定制的应用），虽然手机可以用了； 但是，如果从版本A线刷至版本B，系统版本号会造成混乱。所以我们需要单独卡刷cust镜像。 加载上边解包出来的cust.img，另存为EXT4格式文件； 命名为：cust.img.mount保存好 ;用Winrar直接打开cust.zip（不要解压），把上边存好的cust.img.mount拖进窗口内替换，点确定即可： （在此感谢 @ KillProcess大神原包HRT-KIW-AL10-B180-V5.0，小版只是修改了updater-script，并删掉了boot.img和systme.img.mount） 四、工具包准备： 我们需要把上边解包出来的system.img和boot.img，还有下载的工具包内的TWRP_CN.rar解压后的TWRP_CN.img，一同放在线刷工具包内。就可以开工线刷了。 （安装ADB驱动在回复可见部分；如何打开USB调适，等等…此处省略119个中国字儿） 五、线刷：请手动进入fastboot或在开机状态下，点我进入： boot.img recovery.img 因为小，所以很快就完成了； system.img很大，因而必须化整为零散(sparse)的刷… 所以请耐心等待… 一共用了2分多种，线刷完成，手机会重启，再重启，别怕~ 六、卡刷： 如果手机没能自动重启至这个界面，请手动进入；如果有SD卡的，请将上边制作好cust.zip和解包出来的官方Recovery.img复制到根目录下； 或者直接在TWRP Rec下操作，搞进内置存贮也一样： 启用MTP，电脑上会出现手机的内置存贮，和移动U盘一样，按上边说的做； 我们要刷2个包，一个是cust.zip，另一个是recovery.img；不过新版本的TWRP Rec都是支持的： 建议先安装cust.zip，完成后使用导航栏返回主页继续 安装-刷入官方Recovery镜像； 最后，到返回主页，重启：Recovery（这就回到官方了）恢复出厂设置（如果没有使用官方Recovery恢复出厂设置，16G内存一定会严重缩水），完后重启（收工）： 要知道这可是从Emui4 暴力回退的，B191版本，无法收到Emui 4版本的推送；同样的方法，可回退B160，172，虽然能检查更新，但无法升级安装，只有在B180 版本上，能够检查更新收到推送，OTA升级&#x2F;本地安装Emui 4 增量包（嘿嘿~是在OTA安装前，从内存中搞出来的包），可顺利完成升级。 不知道什么原因；通过以上线刷+卡刷的方式，从Emui4 暴力回退 3.1后，3.1的任何版本，都无法再升级安装了。 PS：教程中所使用的工具，有可能需要安装微软.Net framework 框架： （这几天折腾的，实在无法确定这一点，如果有无法使用的情况，建议连Java jdk也都安装好。） PS+1：小版这里的电脑平台是Windows 10 专业版 1511（内部版本 10586.122）以上内容，是以KIW-AL10（全网通）机型为例，其它机型未测（因而不能确定是否可行） 刷机是有风险的，后果请自行承担；本教程，旨在于研究&#x2F;救砖&#x2F;回退&#x2F;刷回官方等，分享在此，为有需要者参阅。 哦！差点忘了，工具的下载地址："}]